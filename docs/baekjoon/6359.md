---
title: 6359. 만취한 상범
description: 백준 6359번 풀이
date: 2022-02-04
tags:
  - { 난이도 }
  - 구현
---

# {{ $frontmatter.title }}

> {{ $frontmatter.description }}

> [!NOTE]
> 이 글은 Obsidian에서 마이그레이션되었으며, 그 과정에서 AI의 도움을 받았습니다.
> 오류나 누락된 내용이 있다면 댓글로 알려주세요!

## 문제

[6359번: 만취한 상범](https://www.acmicpc.net/problem/6359)

## 풀이

### 아이디어

복잡하게 생각할 필요 없다. 그냥... 반복문 중첩해서 구구단 구현해서 해당하는 방들 열었다 닫았다 해 주고 마지막까지 열려있는 방의 개수를 구해주면 된다. (설명하는 것 보다 코드를 보는게 더 쉬울 듯 하다.)

생각한 그대로를 코드로 구현할 수 있는지를 묻는 문제인 것 같다.

### 코드

```cpp
/*
2022-2-3
6359_만취한 상범
https://www.acmicpc.net/problem/6359
*/

#include <iostream>
using namespace std;

int t, n, cnt;
bool room[101];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> t;
	while (t--){
		cin >> n;
		// 초기화
		cnt = 0;
		for (int i = 1; i <= n; i++)
			room[i] = false;	// 잠금
		// 열려있으면 잠그기, 잠겨있으면 열기
		for(int k = 1; k <= n; k++){
			for(int i = 1; i * k <= n; i++){
				if (room[i * k])
					room[i * k] = false;
				else
					room[i * k] = true;
			}
		}
		// 열려있는 것 세어주기
		for(int i = 1; i <= n; i++){
			if (room[i])
				cnt++;
		}
		cout << cnt << '\n';
	}

	return (0);
}
```
